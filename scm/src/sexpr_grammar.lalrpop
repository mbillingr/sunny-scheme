use lalrpop_util::ParseError;
use std::borrow::Cow;
use std::collections::HashMap;
use std::str::FromStr;
use crate::parser::unescape;
use crate::Scm;
use crate::source_location::SourceLocation;
use crate::source_map::SourceMap;
use crate::scm::number::Number;
use crate::lexer::{self, LexicalError};

grammar<'input>(context: &'input SourceLocation<()>, source_map: &SourceMap, datum_labels: &mut HashMap<usize, Scm>);


pub ExplicitSequence: Vec<Scm> = {
    Datum*
};

pub Datum: Scm = {
    <i:"label-def"> <d:Datum> => { datum_labels.insert(i, d.clone()); d },
    <l:@L> <i:"label-ref"> <r:@R> =>? {
        let src = context.clone().with_span(l..r);
        let sexpr = datum_labels
            .get(&i)
            .cloned()
            .ok_or(LexicalError::User("undefined datum label".to_string()))?;
        source_map.insert(sexpr.clone(), src);
        Ok(sexpr)
    },
    <l:@L> <x:SimpleOrCompoundDatum> <r:@R> => {
        let src = context.clone().with_span(l..r);
        source_map.insert(x.clone(), src);
        x
    },
};

SimpleOrCompoundDatum: Scm = {
    SimpleDatum,
    CompoundDatum
}

SimpleDatum: Scm = {
    Bool => Scm::bool(<>),
}

CompoundDatum: Scm = {
    Quotation
}

Bool: bool = {
    "#t" => true,
    "#f" => false,
}

Quotation: Scm = {
    <l:@L> "'" <r:@R> <x:Datum> => {
        let quote = Scm::symbol("quote");
        let src = context.clone().with_span(l..r);
        source_map.insert(quote.clone(), src);
        Scm::list(vec![quote, x].into_iter())
    }
};

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok<'input> {
        "label-def" => lexer::Tok::LabelDef(<usize>),
        "label-ref" => lexer::Tok::LabelRef(<usize>),
        "#t" => lexer::Tok::True,
        "#f" => lexer::Tok::False,
        "'" => lexer::Tok::Quotation,
    }
}