use lalrpop_util::ParseError;
use std::borrow::Cow;
use std::collections::HashMap;
use std::str::FromStr;
use crate::parser::unescape;
use crate::Scm;
use crate::source_location::SourceLocation;
use crate::source_map::SourceMap;
use crate::scm::number::Number;

grammar<'a>(context: &'a SourceLocation<()>, source_map: &SourceMap, datum_labels: &mut HashMap<&'input str, Scm>);

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r";[^\n\r]*[\n\r]*" => LINE_COMMENT,
    r"#\|[^|]*\|+([^|#][^|]*\|+)*#" => BLOCK_COMMENT,
} else {
    r"#t(?:|rue)" => BOOLEAN_TRUE,
    r"#f(?:|alse)" => BOOLEAN_FALSE,
    r"(?:#b(?:#[ei])?|(?:#[ei])?#b)(?:(?:[+-]?(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)@(?:[+-]?(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)|(?:[+-]?(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)\+(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)i|(?:[+-]?(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)-(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)i|(?:[+-]?(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)\+i|(?:[+-]?(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)-i|(?:[+-]?(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)(?:\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)i|\+(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)i|-(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)i|(?:\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)i|\+i|-i|[+-]?(?:[01]+/[01]+|[01]+\.[01]*(?:e[+-]?[01]+)?|\.[01]+(?:e[+-]?[01]+)?|[01]+(?:e[+-]?[01]+)?|[01]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)" => NUM2,
    r"(?:#o(?:#[ei])?|(?:#[ei])?#o)(?:(?:[+-]?(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)@(?:[+-]?(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)|(?:[+-]?(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)\+(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)i|(?:[+-]?(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)-(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)i|(?:[+-]?(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)\+i|(?:[+-]?(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)-i|(?:[+-]?(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)(?:\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)i|\+(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)i|-(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)i|(?:\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)i|\+i|-i|[+-]?(?:[0-7]+/[0-7]+|[0-7]+\.[0-7]*(?:e[+-]?[0-7]+)?|\.[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+(?:e[+-]?[0-7]+)?|[0-7]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)" => NUM8,
    r"(?:(?:#d)?(?:#[ei])?|(?:#[ei])?(?:#d)?)(?:(?:[+-]?(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)@(?:[+-]?(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)|(?:[+-]?(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)\+(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)i|(?:[+-]?(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)-(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)i|(?:[+-]?(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)\+i|(?:[+-]?(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)-i|(?:[+-]?(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)(?:\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)i|\+(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)i|-(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)i|(?:\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)i|\+i|-i|[+-]?(?:[0-9]+/[0-9]+|[0-9]+\.[0-9]*(?:e[+-]?[0-9]+)?|\.[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+(?:e[+-]?[0-9]+)?|[0-9]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)" => NUM10,
    r"(?:#x(?:#[ei])?|(?:#[ei])?#x)(?:(?:[+-]?(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)@(?:[+-]?(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)|(?:[+-]?(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)\+(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)i|(?:[+-]?(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)-(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)i|(?:[+-]?(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)\+i|(?:[+-]?(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)-i|(?:[+-]?(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)(?:\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)i|\+(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)i|-(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)i|(?:\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)i|\+i|-i|[+-]?(?:[0-9a-f]+/[0-9a-f]+|[0-9a-f]+\.[0-9a-f]*(?:e[+-]?[0-9a-f]+)?|\.[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+(?:e[+-]?[0-9a-f]+)?|[0-9a-f]+)|\+inf\.0|-inf\.0|\+nan\.0|-nan\.0)" => NUM16,
} else {
    r"\|(?:[^\|]|\\(?:x[0-9a-f]+;|[abnrt|]))*\|" => VERBATIM_IDENTIFIER,
    r"[!$-&*/:<-Z_a-z~^][!$-&*+.-:<-Z_a-z~^-]*" => NORMAL_IDENTIFIER,
    r"[+-][!$-&*+/:<-Z_a-z~^-][!$-&*+.-:<-Z_a-z~^-]*|[+-]\.[!$-&*+./:<-Z_a-z~^-][!$-&*+.-:<-Z_a-z~^-]*|\.[!$-&*+./:<-Z_a-z~^-][!$-&*+.-:<-Z_a-z~^-]*|[+-]" => PECULIAR_IDENTIFIER,
} else {
    _
}

pub ExplicitSequence: Vec<Scm> = {
    <cd:OptionalDatum*> => cd.into_iter().filter_map(|x|x).collect(),
};

OptionalDatum: Option<Scm> = {
    Comment => None,
    <d:Datum> => Some(d),
};

Comment: () = {
    "#;" Datum,
    LINE_COMMENT,
    BLOCK_COMMENT,
};

Datum: Scm = {
    <i:r"#([0-9]+)="> <d:Datum> => { datum_labels.insert(&i[1..i.len()-1], d.clone()); d },
    <l:@L> <i:r"#([0-9]+)#"> <r:@R> =>? {
        let src = context.clone().with_span(l..r);
        let sexpr = datum_labels
            .get(&i[1..i.len()-1])
            .cloned()
            .ok_or(ParseError::User { error: "undefined datum label" })?;
        source_map.insert(sexpr.clone(), src);
        Ok(sexpr)
    },
    <l:@L> <x:RawSexpr> <r:@R> => {
        let src = context.clone().with_span(l..r);
        source_map.insert(x.clone(), src);
        x
    },
};

RawSexpr: Scm = {
    <b:Bool> => Scm::bool(b),
    <n:Num> => Scm::number(n),
    <ch:Char> => Scm::char(ch),
    <s:Sym> => Scm::symbol(&s),
    <s:Str> => Scm::escaped_string(s),
    <bv:ByteVec> => Scm::bytevector(bv),
    <v:Vec> => Scm::vector(v),
    <l:List> => <>,
    <q:Quotation> => <>,
};

Bool: bool = {
    BOOLEAN_TRUE => true,
    BOOLEAN_FALSE => false,
}

Num: Number = {
    AnyNumber =>? Number::from_str(<>).map_err(|msg| ParseError::User { error: Box::leak(msg.into_boxed_str()) as &'static str })
}

AnyNumber = {
    NUM2, NUM8, NUM10, NUM16
}

Char: char = {
    <s:r"#\\[xX][0-9A-Fa-f]+"> =>? u32::from_str_radix(&s[3..], 16)
                                    .ok()
                                    .and_then(std::char::from_u32)
                                    .ok_or(ParseError::User { error: "invalid unicode character" }),
    <l:@L><s:r"#\\[xX][^0-9A-Fa-f]+"><r:@R> =>? match &s[2..] {
                                    "xi" => Ok('ξ'),       "Xi" => Ok('Ξ'),
                                    _ => Err(ParseError::User { error: "invalid named character" })
                                },
    <l:@L><s:r"#\\[^xX][a-zA-Z]+"><r:@R> =>? match &s[2..] {
                                    "alarm" => Ok('\u{0007}'),
                                    "backspace" => Ok('\u{0008}'),
                                    "delete" => Ok('\u{007f}'),
                                    "escape" => Ok('\u{001b}'),
                                    "newline" => Ok('\n'),
                                    "null" => Ok('\u{0000}'),
                                    "return" => Ok('\r'),
                                    "space" => Ok(' '),
                                    "tab" => Ok('\t'),

                                    "alpha" => Ok('α'),    "Alpha" => Ok('Α'),
                                    "beta" => Ok('β'),     "Beta" => Ok('Β'),
                                    "gamma" => Ok('γ'),    "Gamma" => Ok('Γ'),
                                    "delta" => Ok('δ'),    "Delta" => Ok('Δ'),
                                    "epsilon" => Ok('ε'),  "Epsilon" => Ok('Ε'),
                                    "zeta" => Ok('ζ'),     "Zeta" => Ok('Ζ'),
                                    "eta" => Ok('η'),      "Eta" => Ok('Η'),
                                    "theta" => Ok('θ'),    "Theta" => Ok('Θ'),
                                    "iota" => Ok('ι'),     "Iota" => Ok('Ι'),
                                    "kappa" => Ok('κ'),    "Kappa" => Ok('Κ'),
                                    "lambda" => Ok('λ'),   "Lambda" => Ok('Λ'),
                                    "mu" => Ok('μ'),       "Mu" => Ok('Μ'),
                                    "nu" => Ok('ν'),       "Nu" => Ok('Ν'),
                                    // xi is treated specially because of the leading x
                                    "omicron" => Ok('ο'),  "Omicron" => Ok('Ο'),
                                    "pi" => Ok('π'),       "Pi" => Ok('Π'),
                                    "rho" => Ok('ρ'),      "Rho" => Ok('Ρ'),
                                    "2sigma" => Ok('ς'),
                                    "sigma" => Ok('σ'),    "Sigma" => Ok('Σ'),
                                    "tau" => Ok('τ'),      "Tau" => Ok('Τ'),
                                    "upsilon" => Ok('υ'),  "Upsilon" => Ok('Υ'),
                                    "phi" => Ok('φ'),      "Phi" => Ok('Φ'),
                                    "chi" => Ok('χ'),      "Chi" => Ok('Χ'),
                                    "psi" => Ok('ψ'),      "Psi" => Ok('Ψ'),
                                    "omega" => Ok('ω'),    "Omega" => Ok('Ω'),

                                    _ => Err(ParseError::User { error: "invalid named character" })
                                },
    <s:r"#\\."> => s[2..].chars().next().unwrap(),
};

Sym: Cow<'input, str> = {
    <s:NORMAL_IDENTIFIER> => Cow::Borrowed(s),
    <s:PECULIAR_IDENTIFIER> => Cow::Borrowed(s),
    <s:VERBATIM_IDENTIFIER> =>? unescape(&s[1..s.len()-1]),
}

Str: &'input str = {
    <s:r#""[^"]*""#> => &s[1..s.len()-1],
};

List: Scm = {
    "(" ")" => Scm::null(),
    "(" <Sequence> ")" => <>,
};

Sequence: Scm = {
    <car:Comment> <seq:Sequence> => seq,
    <car:Datum> <l:@L> <cdr:Sequence> <r:@R> => {
        let src = context.clone().with_span(l..r);
        source_map.insert(cdr.clone(), src);
        Scm::cons_const(car, cdr)
    },
    <car:Datum> "." <cdr:Datum> => Scm::cons_const(car, cdr),
    <car:Datum> => Scm::cons_const(car, Scm::null()),
};

Quotation: Scm = {
    <l:@L> "'" <r:@R> <x:Datum> => {
        let quote = Scm::symbol("quote");
        let src = context.clone().with_span(l..r);
        source_map.insert(quote.clone(), src);
        Scm::list(vec![quote, x].into_iter())
    }
};

Vec: Vec<Scm> = {
    "#(" ")" => vec![],
    "#(" <VecSequence> ")" => <>,
}

VecSequence: Vec<Scm> = {
    <singleton:Datum> => vec![singleton],
    <mut head:VecSequence> <last:Datum> => { head.push(last); head },
};

ByteVec: Vec<u8> = {
    "#u8(" ")" => vec![],
    "#u8(" <ByteSequence> ")" => <>,
}

ByteSequence: Vec<u8> = {
    <singleton:ByteNum> => vec![singleton],
    <mut head:ByteSequence> <last:ByteNum> => { head.push(last); head },
}

ByteNum: u8 = {
    <Num> =>? <>.to_u8().ok_or_else(||ParseError::User { error: "invalid byte constant" })
}
