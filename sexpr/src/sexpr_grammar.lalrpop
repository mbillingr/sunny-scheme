use lalrpop_util::ParseError;
use std::borrow::Cow;
use std::collections::HashMap;
use std::str::FromStr;
use crate::parser::unescape;
use crate::Scm;
use crate::source_location::SourceLocation;
use crate::source_map::SourceMap;

grammar<'a>(context: &'a SourceLocation<()>, source_map: &SourceMap, datum_labels: &mut HashMap<&'input str, Scm>);

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r";[^\n\r]*[\n\r]*" => LINE_COMMENT,
    r"#\|[^|]*\|+([^|#][^|]*\|+)*#" => BLOCK_COMMENT,
    ".",
    r"\|(\\\||[^|])*\|" => VERBATIM_SYMBOL,
    r"[a-zA-Z!$%&*+./:<=>?@^_~-]([^\s\(\)])*" => IDENTIFIER,
} else {
    _
}

pub ExplicitSequence: Vec<Scm> = {
    <cd:OptionalDatum*> => cd.into_iter().filter_map(|x|x).collect(),
};

OptionalDatum: Option<Scm> = {
    Comment => None,
    <d:Datum> => Some(d),
};

Comment: () = {
    "#;" Datum,
    LINE_COMMENT,
    BLOCK_COMMENT,
};

Datum: Scm = {
    <i:r"#([0-9]+)="> <d:Datum> => { datum_labels.insert(&i[1..i.len()-1], d.clone()); d },
    <l:@L> <i:r"#([0-9]+)#"> <r:@R> =>? {
        let src = context.clone().with_span(l..r);
        let sexpr = datum_labels
            .get(&i[1..i.len()-1])
            .cloned()
            .ok_or(ParseError::User { error: "undefined datum label" })?;
        source_map.insert(sexpr.clone(), src);
        Ok(sexpr)
    },
    <l:@L> <x:RawSexpr> <r:@R> => {
        let src = context.clone().with_span(l..r);
        source_map.insert(x.clone(), src);
        x
    },
};

RawSexpr: Scm = {
    <b:Bool> => Scm::bool(b),
    <n:Num> => Scm::int(n),
    <s:Sym> => Scm::symbol(&s),
    <s:Str> => Scm::string(s),
    <l:List> => <>,
    <q:Quotation> => <>,
};

Bool: bool = {
    "#t" => true,
    "#f" => false,
}

Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();

Sym: Cow<'input, str> = {
    <s:IDENTIFIER> => Cow::Borrowed(s),
    <s:VERBATIM_SYMBOL> =>? unescape(&s[1..s.len()-1]),
}

Str: &'input str = {
    <s:r#""[^"]*""#> => &s[1..s.len()-1],
};

List: Scm = {
    "(" ")" => Scm::null(),
    "(" <Sequence> ")" => <>,
};

Sequence: Scm = {
    <car:Comment> <seq:Sequence> => seq,
    <car:Datum> <l:@L> <cdr:Sequence> <r:@R> => {
        let src = context.clone().with_span(l..r);
        source_map.insert(cdr.clone(), src);
        Scm::cons(car, cdr)
    },
    <car:Datum> "." <cdr:Datum> => Scm::cons(car, cdr),
    <car:Datum> => Scm::cons(car, Scm::null()),
};

Quotation: Scm = {
    <l:@L> "'" <r:@R> <x:Datum> => {
        let quote = Scm::symbol("quote");
        let src = context.clone().with_span(l..r);
        source_map.insert(quote.clone(), src);
        Scm::list(vec![quote, x].into_iter())
    }
};
